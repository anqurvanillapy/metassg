<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="static/codehilite.css">
  <link rel="stylesheet" type="text/css" href="static/style.css">

  <title>Postocol</title>
</head>
<body>

<header>
<h1>Postocol</h1>
</header>

<hr>

<main>
<article><p><strong>Posting Protocol</strong>, SSG (static site generator) abstract class for extensible
use.</p>
<blockquote>
<p>Fork me on <a href="https://github.com/anqurvanillapy/postocol">GitHub</a>!</p>
</blockquote>
<h2>Implementation Workflow</h2>
<ul>
<li>There are <strong>3</strong> document types that Postocol mainly serves, which are:<ul>
<li>Single page (e.g. slideshow)</li>
<li>Blog</li>
<li>Wiki</li>
</ul>
</li>
<li>Therefore, Postocol will by default trace <strong>6</strong> types of templates as follows:<ul>
<li><code>index</code>, for blog or wiki, or even the slideshow (because it can be stored
in one static HTML file, hence assuming that it is an index page)</li>
<li><code>post</code>, for blog or wiki, e.g. an article</li>
<li><code>states</code>, mainly for wiki, a list containing the current states of a post,
e.g. <em>unfinished</em>, <em>not proofread</em>, <em>stub</em>, etc., similar to
<a href="https://en.wikipedia.org/wiki/Wikipedia:Tagging_pages_for_problems">Wikipedia:Tagging pages for problems</a></li>
<li><code>properties</code>, for wiki or blog, a list of the properties of a post, e.g.
<em>howto</em>, <em>daily</em>, <em>compsci</em>, <em>PoC</em>, etc., similarly the categories or tags</li>
<li><code>misc</code>, something you want to provide independently, instead of listing in
<code>index</code>, <code>states</code> or <code>properties</code>, e.g. <em>about</em>, <em>contact</em>, <em>resume</em>, etc.</li>
<li><code>layout</code>, serving something above</li>
</ul>
</li>
<li><strong>Additionally</strong>, <code>index</code>, <code>states</code> and <code>properties</code> could be automatically
generated from self-implemented <code>Postocol.render()</code> method.</li>
</ul>
<h3>For single-page (slideshow) generator</h3>
<p>There is no need to <code>clean()</code> anything and <code>send_static()</code> for a single-page
generator, so the workflow is simple. For instance, a slideshow generator might
act like this.</p>
<div class="codehilite"><pre><span></span>                    load_templates()     publish()
                          |                  |
                          v                  v
(slides.md) --+------- template ---+--&gt; (index.html)
              |                    |
              +-- post ---&gt; page --+
                   ^          ^
                   |          |
            load_posts()   render()
</pre></div>
<h3>For blog/wiki generator</h3>
<p>Wiki uses the whole functionality to update all the posts, whereas the workflow
of a blog generator is similar:</p>
<div class="codehilite"><pre><span></span>(foo.md) --+
(bar.md) --+  clean(site/)  load_templates()  publish()  send_static()
           |         |            |              |             |
           v         v            v              v             v
       (content/) ---+----- templates ---+--&gt; (site/) --+-&gt; (site/static/)
                     |                   |              +-- (index.html)
                     +-- posts -&gt; pages -+              +-- (states.html)
                          ^         ^                   +-- (properties.html)
                          |         |                   +-- (foo.html)
                   load_posts()  render()               +-- (bar.html)
</pre></div>
<h2>Examples</h2>
<h3>Starter</h3>
<p>The project site hosted on
<a href="https://github.com/anqurvanillapy/postocol/tree/gh-pages">gh-pages branch</a>
contains a minimalist webpage generator that ignores two unnecessary methods
<code>clean()</code> and <code>send_static()</code>, which can be your first sight under the hood.</p>
<blockquote>
<p>Off we go!</p>
</blockquote>
<p>First, import everything we need to implement our own <code>render()</code> method. <code>os</code>
module can help us modify the filenames in the following steps. In the meantime,
create a class inheriting <code>Postocol</code> with some key constants.</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">postocol</span> <span class="kn">import</span> <span class="n">Postocol</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">basename</span><span class="p">,</span> <span class="n">splitext</span>


<span class="k">class</span> <span class="nc">Starter</span><span class="p">(</span><span class="n">Postocol</span><span class="p">):</span>
    <span class="n">ifpath</span> <span class="o">=</span> <span class="s1">'preface.md'</span>
    <span class="n">ofpath</span> <span class="o">=</span> <span class="s1">'index.html'</span>
</pre></div>
<p>Second, we add a <code>run()</code> method for the control flow, which goes like</p>
<blockquote>
<p>Load templates from <code>templates</code> folder, and load <code>preface.md</code> to a list called
<code>posts</code>. Render the Markdown file and bring the <code>pages</code> out. Phew, finally, we
can publish it to the file <code>index.html</code> right now, which is combined with our
<code>templates</code> and <code>pages</code>.</p>
</blockquote>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tmpls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_templates</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">posts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_posts</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pages</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">posts</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">publish</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pages</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmpls</span><span class="p">)</span>
</pre></div>
<p>Eventually, here comes the boss! Now implement the abstract method <code>render()</code> to
extract the list of posts tuples to do some manipulation, and pass it to our
pages list. <code>Postocol.load_posts()</code> collects <strong>3</strong> kinds of the page data:
<code>content</code> (the generated HTML content), <code>meta</code> (title, type, date,
etc., right at the beginning of a Markdown post) and <code>fname</code> (filename). Since
we don't need to do something like auto-generating a table of contents in index,
we now can straightly pass them to the page list.</p>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">posts</span><span class="p">):</span>
    <span class="n">pages</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Tiny function to extract the filename and add a `.html` extension</span>
    <span class="n">chfn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s1">'{}.html'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">basename</span><span class="p">(</span><span class="n">x</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">posts</span><span class="p">:</span>
        <span class="c1"># Jinja2 renders the templates using kwargs, hence `pages` is a list</span>
        <span class="c1"># of the dicts</span>
        <span class="n">pages</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">'content'</span><span class="p">:</span> <span class="n">c</span><span class="p">,</span> <span class="s1">'meta'</span><span class="p">:</span> <span class="n">m</span><span class="p">,</span> <span class="s1">'fname'</span><span class="p">:</span> <span class="n">chfn</span><span class="p">(</span><span class="n">f</span><span class="p">)})</span>

    <span class="k">return</span> <span class="n">pages</span>
</pre></div>
<p>What is inside the <code>preface.md</code> and the index template will not be displayed
right here. Check out the
<a href="https://github.com/anqurvanillapy/postocol/tree/gh-pages">branch</a>, where the
generator uses <code>Postocol.send_codehilite_style()</code> to create code highlighting
stylesheet for the code snippets. Run the script to see what magic will happen!</p>
<h3>Main Course</h3>
<p>See <a href="https://github.com/anqurvanillapy/postocol/tree/master/examples">examples</a>
directory that offers a fully implemented <strong>wiki</strong> generator demo, which may
help you fast-prototyping your own generator.</p></article>
</main>

<hr>

<footer>
<p>
Published by
<a href="https://github.com/anqurvanillapy/postocol">Postocol</a>,
indeed.
</p>
</footer>

</body>
</html>